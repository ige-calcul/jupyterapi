"""Adapter Design Pattern for Jupyter Server REST API."""

from __future__ import annotations

import logging

import requests
import urllib3

from .api_utils import get_api_url
from .exceptions import JupyterApiError
from .models import Result


class RestAdapter:
    """API wrapper to run generic HTTP requests."""

    def __init__(
        self,
        url: str,
        token: str,
        *,
        ssl_verify: bool = True,
        logger: logging.Logger | None = None,
    ) -> None:
        """
        Initialize the main API endpoint and set authentication token.

        :param url: URL of the Jupyter Server API
        :param token: Token generated by the user to allow use the Jupyter Server API
        :params logger: (optional) If app has a custom logger, pass it in here
        :param ssl_verify: Validate the SSL connection, should remain set to True
        """
        self.url = get_api_url(url)
        self._token = token
        self._ssl_verify = ssl_verify
        self._logger = logger or logging.getLogger(__name__)
        if not ssl_verify:
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def _do(
        self,
        http_method: str,
        endpoint: str,
        ep_params: dict | None = None,
        data: dict | None = None,
    ) -> Result:
        """Run HTTP generic request to Jupyter Server API."""
        full_url = self.url + endpoint
        headers = {"Authorization": f"token {self._token}"}
        log_extra = {"method": http_method, "url": full_url, "params": ep_params}
        try:
            self._logger.debug("HTTP request launched", extra=log_extra)
            response = requests.request(
                http_method,
                url=full_url,
                verify=self._ssl_verify,
                headers=headers,
                params=ep_params,
                json=data,
                timeout=10,
            )
        except requests.exceptions.RequestException as e:
            msg = "HTTP request failed"
            self._logger.exception(msg, extra=log_extra)
            raise JupyterApiError(msg) from e

        log_extra.update(
            {
                "success": response.ok,
                "status_code": response.status_code,
                "message": response.reason,
            },
        )
        try:
            data_out = response.json()
        except (ValueError, requests.exceptions.JSONDecodeError) as e:
            msg = "Bad JSON in HTTP response"
            self._logger.exception(msg, extra=log_extra)
            raise JupyterApiError(msg) from e

        if response.ok:
            self._logger.debug("HTTP request successful", extra=log_extra)
            return Result(response.status_code, response.reason, data_out)

        msg = f"HTTP request failed ({response.status_code}): {response.reason}"
        self._logger.exception(msg, extra=log_extra)
        raise JupyterApiError(msg)

    def get(self, endpoint: str, ep_params: dict | None = None) -> Result:
        """Run HTTP GET request to Jupyter Server API."""
        return self._do(http_method="GET", endpoint=endpoint, ep_params=ep_params)

    def patch(
        self,
        endpoint: str,
        ep_params: dict | None = None,
        data: dict | None = None,
    ) -> Result:
        """Run HTTP PATCH request to Jupyter Server API."""
        return self._do(
            http_method="PATCH",
            endpoint=endpoint,
            ep_params=ep_params,
            data=data,
        )

    def post(
        self,
        endpoint: str,
        ep_params: dict | None = None,
        data: dict | None = None,
    ) -> Result:
        """Run HTTP POST request to Jupyter Server API."""
        return self._do(
            http_method="POST",
            endpoint=endpoint,
            ep_params=ep_params,
            data=data,
        )

    def put(
        self,
        endpoint: str,
        ep_params: dict | None = None,
        data: dict | None = None,
    ) -> Result:
        """Run HTTP PUT request to Jupyter Server API."""
        return self._do(
            http_method="PUT",
            endpoint=endpoint,
            ep_params=ep_params,
            data=data,
        )

    def delete(
        self,
        endpoint: str,
        ep_params: dict | None = None,
        data: dict | None = None,
    ) -> Result:
        """Run HTTP DELETE request to Jupyter Server API."""
        return self._do(
            http_method="DELETE",
            endpoint=endpoint,
            ep_params=ep_params,
            data=data,
        )
